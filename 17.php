<?php



session_start();

include ('mysql.php');

	include('authentification.php');
	
		$page_num=17;

echo '

<!--  -->
<!DOCTYP html>
<html>
	<head>
		<title></title>
		<meta http-equiv="Content-Type" content="text/html;charset=windows-1251" />
		<link rel="stylesheet" href="style.css" type="text/css">		
		</head>

<body>

	<header id="page_header">
		<nav>			
				<div id="oglavlenie">
				
					<ul id="ul1">
					
';

include('oglavlenie.php');

echo '
					</ul>
				
				</div>	
				<div id="zakladki">					
					<ul id="ul1">
					
';

include('zakladky.php');

echo '
					</ul>						
				</div>	
				
				<div id="reg">
					<div>
					
';

include('auth.php');

echo '
					</div>
				</div>
				
				<div id="menu">
				
';

include('menu.php');

echo '

				</div>
		</nav>
	</header>

	<section id="content">
		<div id="content1">
			<div id="content2">	
<p id="z">
Классы</p><br />

<i></i><br />



<i>Собственные классы</i><br /><br />

<p>
 Ниже приводится синтаксис, используемый при создании собственных классов:
</p><br />
 
<p id="code">
class className: suite<br />
class className(base_classes): suite<br />
</p><br />

<p>
 Обратите внимание: как и
 инструкция def, инструкция class является самой обычной инструкцией, что дает возможность создавать классы динамически,
 когда в этом возникнет необходимость. Методы класса создаются с помощью инструкций def внутри блока кода класса.
 Экземпляры класса создаются посредством обращения к имени класса, как к функции, которой передаются все необходимые 
 аргументы. Например, инструкция х = complex(4, 8) создаст комплексное число и запишет ссылку на него в переменную х.
 </p><br />
 
 
<i>Атрибуты и методы</i><br /><br />


<p>
Начнем с очень простого класса Point, который хранит координаты точки (х, у). Определение класса находится в файле Shape.py,
 а ниже приводится его полная реализация (за исключением строк документирования):
 </p><br />
 
 <p id="code">
class Point:<br />
&nbsp;&nbsp;&nbsp;&nbsp;
def 	init	(self, x=0, y=0):<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
self.x = x self.у = у<br />
&nbsp;&nbsp;&nbsp;&nbsp;
def distance_from_origin(self):<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
return math.hypot(self.x, self.y)<br />
&nbsp;&nbsp;&nbsp;&nbsp;
def __eq__(self, other):<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
return self.x == other.x and self.y == other.у<br />
&nbsp;&nbsp;&nbsp;&nbsp;
def __repr__(self):<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
return "Point({0.x! r}, {0.y!r})".format(self)<br />
&nbsp;&nbsp;&nbsp;&nbsp;
def __str__(self):<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
return ”({0.x! r}, {0.y!r})".format(self)<br />
</p><br />

<p>
Поскольку базовый класс не был указан явно, класс Point является прямым наследником класса object, как если бы было записано 
определение class Point (object). Прежде чем приступать к обсуждению всех его методов, рассмотрим несколько примеров их использования:
</p><br />

<p id="code">
import Shape а = Shape.Point()<br />
repr(a)	# вернет: "Point(0, 0)"<br />
b = Shape.Point(3, 4)<br />
str(b)	# вернет: ’(3, 4)"<br />
b.distance_from_origin() # вернет: 5.0<br />
b.	x = -19<br />
str(b)	# вернет: ’(-19, 4)’<br />
а == b, а != b	# вернет: (False, True)<br />
</p><br />

<p>
Класс Point имеет два атрибута данных, self. х и self. у, и пять методов (не считая унаследованных методов), из которых четыре являются специальными 
методами - они показаны на рис. 6.2. После импорти­рования модуля Shape появляется возможность использовать класс Point, как любой другой класс.
 Доступ к атрибутам можно осуществ­лять непосредственно (например, у = а. у), а сам класс отлично интег­рируется со всеми остальными классами языка
 Python, обеспечивая поддержку оператора равенства (==) и представления класса в репрезентативной и строковой формах.
</p><br />

 <p>
 Интерпретатор Python 
 достаточно умен, чтобы обеспечить поддержку оператора неравенства (! =) на основе имеющейся поддержки оператора равенства. (Однако имеется 
 возможность реализовать поддержку каждого оператора в отдельности, если потребуется обеспечить полный контроль, когда, к примеру, один оператор 
 не является полной противоположностью другому.)
 </p><br />
 
 <p>
При вызове метода интерпретатор автоматически передает ему первый аргумент - ссылку на сам объект (в языках C++ и Java она имеет имя this). 
В соответствии с соглашениями мы обязаны включать этот пара­метр в список под именем self. Все атрибуты объекта (данные и методы) должны 
квалифицироваться именем self. При этом потребуется вводить с клавиатуры чуть больше, чем в других языках программи­рования, но в этом есть 
свое преимущество - полная ясность: мы все­гда точно знаем, что обращаемся к атрибуту объекта, если квалифици­руем его именем self.
</p><br />

<p>
Чтобы создать объект, необходимо выполнить два действия. Сначала необходимо создать неинициализированную заготовку объекта, а затем необходимо 
подготовить объект к использованию, инициализировавего. В некоторых языках программирования (таких как C++ и Java) эти два действия 
объединены в одно, но в языке Python они выполня­ются отдельно друг от друга.
</p><br />


					
			</div>
		</div>
	</section>

	<footer id="page_footer">
		<hr color="CFDBF5">
		<a href="http://vk.com/id36162788">Царев А.</a> 2013
	</footer>

</body>

</html>

';

?>