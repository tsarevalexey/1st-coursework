<?php



session_start();

include ('mysql.php');

	include('authentification.php');
	
		$page_num=13;

echo '

<!--  -->
<!DOCTYP html>
<html>
	<head>
		<title></title>
		<meta http-equiv="Content-Type" content="text/html;charset=windows-1251" />
		<link rel="stylesheet" href="style.css" type="text/css">		
		</head>

<body>

	<header id="page_header">
		<nav>			
				<div id="oglavlenie">
				
					<ul id="ul1">
					
';

include('oglavlenie.php');

echo '
					</ul>
				
				</div>	
				<div id="zakladki">					
					<ul id="ul1">
					
';

include('zakladky.php');

echo '
					</ul>						
				</div>	
				
				<div id="reg">
					<div>
					
';

include('auth.php');

echo '
					</div>
				</div>
				
				<div id="menu">
				
';

include('menu.php');

echo '

				</div>
		</nav>
	</header>

	<section id="content">
		<div id="content1">
			<div id="content2">	
<p id="z">
Ошибки и исключения</p><br />

<i></i><br />


<p>
До сих пор мы лишь упоминали об ошибках, но если Вы пробовали приведенные приме­ры, то могли увидеть некоторые из них. Можно выделить (как минимум) два различимых типа ошибок: синтаксические ошибки и исключения1.
</p><br />


		<i>Синтаксические ошибки</i><br /><br />
		
		
<p>	
Синтаксические ошибки, пожалуй, чаще всего встречаются во время изучения языка:
</p><br />

<p id="code">
>>> while 1 print "Hello world"<br />
File "<stdin>", line 1<br />
while 1 print "Hello world"<br />
SyntaxError: invalid syntax<br />
</p><br />

<p>
Синтаксический анализатор выводит строку, содержащую ошибку, и указывает место, где ошибка была обнаружена. Ошибка обычно вызвана лексемой, предшествующей стрелке: в приведенном примере, ошибка обнаружена на месте ключевого слова print, так как перед ним отсутствует двоеточие (‘:’). Имя файла и номер строки выводится для того, чтобы Вы знали, где искать ошибку в случае, если инструкции считываются из файла.
</p><br />


		<i>Исключения</i><br /><br />
		
		
<p>		
Даже если инструкция или выражение синтаксически верно, ошибка может произойти при попытке выполнения. Ошибки, обнаруженные во время выполнения, не являются безусловно фатальными, и скоро Вы узнаете, как их можно обрабатывать в программах на языке Python. Большинство исключений, однако, не обрабатываются программами и приводят к сообщениям об ошибке:
</p><br />

<p id="code">
>>> 10 * (1/0)<br />
Traceback (innermost last):<br />
"Синтаксические ошибки также являются исключениями, которые, однако, не могут быть перехвачены на том же уровне."<br />
File "<stdin>", line 1 ZeroDivisionError: integer division or modulo >>> 4 + spam3 Traceback (innermost last):<br />
File "<stdin>", line 1 NameError: spam >>> "2" +2<br />
Traceback (innermost last):<br />
File "<stdin>", line 1 TypeError: illegal argument type for built-in operation<br />
</p><br />

<p>
Последняя строка сообщения показывает, что произошло. Исключения бывают раз­ного типа — он выводится в сообщении. Типы исключений в приведенном примере: ZeroDivisionError, NameError и TypeError. Имена стандартных исключений яв­ляются встроенными идентификаторами, но не являются зарезервированными ключевы­ми словами.
Сразу после типа выводятся подробности возникновения исключения. Предшеству­ющая часть сообщения об ошибке показывает контекст возникновения исключительной ситуации в форме содержимого стека. При этом выводятся строки исходного текста, за исключением строк, читаемых со стандартного ввода.
</p><br />



	<i>Обработка исключений</i><br /><br />
		
		
<p>		
Вы можете писать программы, которые будут обрабатывать определенные исключения. Посмотрите на следующий пример, в котором пользователю будет выдаваться пригла­шение до тех пор, пока не будет введено целое число или выполнение не будет прервано (обычно Ctrl-C). Во втором случае генерируется исключение Keyboardlnterrupt.
</p><br />

<p id="code">
>>> while 1:<br />
try:<br />
&nbsp;&nbsp;&nbsp;&nbsp;
x = int(raw input(<br />
&nbsp;&nbsp;&nbsp;&nbsp;
"Введите, пожалуйста, целое число: "))<br />
&nbsp;&nbsp;&nbsp;&nbsp;
break<br />
except ValueError:<br />
&nbsp;&nbsp;&nbsp;&nbsp;
print "Вы ошиблись. Попробуйте еще раз..."<br />
</p><br />

<p>
Инструкция try работает следующим образом.<br />
•		Если не возникает исключительной ситуации, ветвь except пропускается и вы­полнение инструкции try завершается.<br />
•		Если во время выполнения ветви try генерируется исключение, оставшаяся часть ветви пропускается. Далее, если тип (класс) исключения соответствует указан­ному после ключевого слова except, выполняется ветвь except и выполнение инструкции try завершается.<br />
•		Если исключение не соответствует указанному после ключевого слова except, то оно передается внешнему блоку try или, если обработчик не найден, исключение считается не перехваченным, выполнение прерывается и выводится сообщение об ошибке.<br />
Инструкция try может иметь более одной ветви except, определяя обработчики для разных исключений. Выполняться будет (как максимум) только один из них. Об­рабатываются только исключения, сгенерированные в соответствующей ветви try, но не в других обработчиках инструкции try. После ключевого слова except может быть указано несколько типов исключений в виде кортежа:
</p><br />

<p id="code">
except (RuntimeError, TypeError, NameError):<br />
&nbsp;&nbsp;&nbsp;&nbsp;
pass<br />
</p><br />

<p>
В последней ветви except тип исключения может быть опущен — в этом случае будут обрабатываться все исключения. Используйте такую запись с особой осторожностью — так Вы легко можете замаскировать реальные ошибки! Перехват всех исключений можно использовать для вывода сообщения об ошибке, а затем повторно сгенерировать его (позволяя обрабатывать исключение в другом месте):
</p><br />

<p id="code">
import sys<br />
try:<br />
&nbsp;&nbsp;&nbsp;&nbsp;
f = open("myfile.txt") s = f.readline() i = int(s.strip()) except IOError, exc:<br />
&nbsp;&nbsp;&nbsp;&nbsp;
print "Ошибка ввода/вывода", exc except ValueError:<br />
&nbsp;&nbsp;&nbsp;&nbsp;
print "Не могу преобразовать данные к целому типу." <br />
except:<br />
&nbsp;&nbsp;&nbsp;&nbsp;
print "Неожиданная ошибка:", sys.exc info()[0] raise # повторно генерирует последнее<br />
&nbsp;&nbsp;&nbsp;&nbsp;
#		перехваченное исключение<br />
</p><br />

<p>
После всех ветвей except, инструкция try может содержать ветвь else, кото­рая будет выполняться в случае, если во время выполнения ветви try исключения не генерируются. Например:
</p><br />

<p id="code">
for arg in sys.argv[1:]: try:<br />
&nbsp;&nbsp;&nbsp;&nbsp;
f = open(arg, "r") except IOError:<br />
&nbsp;&nbsp;&nbsp;&nbsp;
print "Не могу открыть", arg else:<br />
&nbsp;&nbsp;&nbsp;&nbsp;
print arg, "содержит", len(f.readlines()), \<br />
&nbsp;&nbsp;&nbsp;&nbsp;
"строк"<br />
&nbsp;&nbsp;&nbsp;&nbsp;
f.close()<br />
</p><br />

<p>
Обычно лучше использовать ветвь else, чем добавлять код в основную ветвь инструк­ции try, так как это позволяет избежать обработки исключений, сгенерированных ко­дом, который Вы вовсе не собирались защищать.
Исключение может иметь ассоциированное с ним значение — аргумент, пере­данный классу исключения при инициализации. Наличие и тип аргумента зависит от типа исключения. Ассоциированное значение используется при получении для исключе­ния строкового значения. Чтобы получить значение исключения, в ветви except после класса исключения (или кортежа классов) укажите переменную:
</p><br />

<p id="code">
>>> try:<br />
&nbsp;&nbsp;&nbsp;&nbsp;
spam()<br />
except NameError, x:<br />
&nbsp;&nbsp;&nbsp;&nbsp;
print "Имя", x, "не определено"<br />
<br />
Имя spam не определено<br />
</p><br />

<p>
Если исключение не обрабатывается, значение исключения выводится в сообщении об ошибке после имени класса исключения.
Обработчик перехватывает не только исключения, сгенерированные непосред­ственно в блоке try, но и в вызываемых из него функциях. Например:
</p><br />

<p id="code">
>>> def this_fails():<br />
&nbsp;&nbsp;&nbsp;&nbsp;
x = 1/0<br />
>>> try:<br />
&nbsp;&nbsp;&nbsp;&nbsp;
this_fails()<br />
except ZeroDivisionError, exc:<br />
&nbsp;&nbsp;&nbsp;&nbsp;
print "Ошибка времени выполнения:", exc<br />
<br />
Ошибка времени выполнения: integer division or modulo<br />
</p><br />

	<i>Генерация исключений</i><br /><br />
	
	
<p>
Инструкция raise позволяет программисту принудительно сгенерировать исключение. Например:
</p><br />

<p id="code">
>>> raise NameError("HiThere")<br />
&nbsp;&nbsp;&nbsp;&nbsp;
Traceback (innermost last):<br />
File "<stdin>", line 1 NameError: HiThere<br />
</p><br />

<p>
В качестве аргумента raise используется экземпляр класса. Класс указывает на тип исключения; аргумент, передаваемый конструктору, обычно описывает “подробно­сти” возникновения исключительной ситуации.
</p><br />

		<i>Исключения, определяемые пользователем</i><br /><br />
		
		
<p>		
Вы можете использовать свои собственные исключения, используя строковые выражения для обозначения его имени (устаревший способ) или создавая новые классы исклю­чения. Например:
</p><br />

<p id="code">
>>> class MyError(Exception): pass <br />
>>> try:<br />
&nbsp;&nbsp;&nbsp;&nbsp;
raise MyError(2*2)<br />
except MyError, e:<br />
&nbsp;&nbsp;&nbsp;&nbsp;
print "Исключение MyError, value равно", e<br />
<br />
Исключение MyError, value равно 4 <br />
>>> raise MyError(1)<br />
Traceback (innermost last):<br />
File "<stdin>", line 1 	main	.MyError: 1<br />
</p><br />


		<i>“Страхование” от ошибок</i><br /><br />
		
		
<p>		
Еще один вариант записи инструкции try — с определением “страховочной” ветви finally, которая будет выполняться при любых обстоятельствах. Например:
</p><br />

<p id="code">
>>> try:<br />
&nbsp;&nbsp;&nbsp;&nbsp;
raise KeyboardInterrupt()<br />
finally:<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
print "До свидания!"<br />
<br />
До свидания!<br />
Traceback (innermost last):<br />
&nbsp;&nbsp;&nbsp;&nbsp;
File "<stdin>", line 2<br />
Keyboardlnterrupt<br />
</p><br />

<p>
Ветвь finally выполняется независимо от того, возникла ли исключительная ситуация во время выполнения блока try или нет, в том числе и если выход происходит по инструкции break или return.
Инструкция try может иметь либо одну или несколько ветвей except, либо одну ветвь finally, но не оба варианта сразу.
</p>
					
			</div>
		</div>
	</section>

	<footer id="page_footer">
		<hr color="CFDBF5">
		<a href="http://vk.com/id36162788">Царев А.</a> 2013
	</footer>

</body>

</html>

';

?>